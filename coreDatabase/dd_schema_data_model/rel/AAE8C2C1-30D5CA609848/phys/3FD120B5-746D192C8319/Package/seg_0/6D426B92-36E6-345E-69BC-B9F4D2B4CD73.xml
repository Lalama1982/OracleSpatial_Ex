<?xml version = '1.0' encoding = 'UTF-8'?>
<PackageOracle class="oracle.dbtools.crest.model.design.storage.oracle.PackageOracle" name="DD_PAYMENT_PKG" directorySegmentName="seg_0" id="6D426B92-36E6-345E-69BC-B9F4D2B4CD73">
<sourceConnName>dd</sourceConnName>
<sourceObjSchema>DD</sourceObjSchema>
<sourceObjName>DD_PAYMENT_PKG</sourceObjName>
<createdBy>bcarter</createdBy>
<createdTime>2015-07-15 22:15:19 UTC</createdTime>
<ownerDesignName>dd_schema_data_model</ownerDesignName>
<owner>29F77958-DE9B-AAEB-4F89-771962185EA5</owner>
<source>CREATE OR REPLACE PACKAGE DD.DD_PAYMENT_PKG&lt;br/&gt;IS&lt;br/&gt;&lt;br/&gt;  FUNCTION process_registration (&lt;br/&gt;    dino_name_p        IN VARCHAR2,&lt;br/&gt;    password1_p        IN VARCHAR2,&lt;br/&gt;    password2_p        IN VARCHAR2,&lt;br/&gt;    dinosaur_id_p      IN INTEGER,&lt;br/&gt;    location_id_p      IN INTEGER,&lt;br/&gt;    about_yourself_p   IN VARCHAR2,&lt;br/&gt;    card_number_p      IN INTEGER,&lt;br/&gt;    amount_p           IN INTEGER)&lt;br/&gt;    RETURN INTEGER;&lt;br/&gt;&lt;br/&gt;  PROCEDURE queue_payment (p_message IN dd_user_payment_type);&lt;br/&gt;&lt;br/&gt;  /* Register a new member using an in-band payment process&lt;br/&gt;   *&lt;br/&gt;   * Using AQ like this means the user is considered valid by the&lt;br/&gt;   * application prior to the payment actually being processed: a free trial!&lt;br/&gt;   *&lt;br/&gt;   * Returns the new member_id&lt;br/&gt;   */&lt;br/&gt;&lt;br/&gt;  FUNCTION process_registration_aq (&lt;br/&gt;    dino_name_p        IN VARCHAR2,&lt;br/&gt;    password1_p        IN VARCHAR2,&lt;br/&gt;    password2_p        IN VARCHAR2,&lt;br/&gt;    dinosaur_id_p      IN INTEGER,&lt;br/&gt;    location_id_p      IN INTEGER,&lt;br/&gt;    about_yourself_p   IN VARCHAR2,&lt;br/&gt;    card_number_p      IN INTEGER,&lt;br/&gt;    amount_p           IN INTEGER)&lt;br/&gt;    RETURN INTEGER;&lt;br/&gt;&lt;br/&gt;  PROCEDURE auto_dequeue (context     RAW,&lt;br/&gt;                          reginfo     SYS.AQ$_REG_INFO,&lt;br/&gt;                          descr       SYS.AQ$_DESCRIPTOR,&lt;br/&gt;                          payload     RAW,&lt;br/&gt;                          payloadl    NUMBER);&lt;br/&gt;&lt;br/&gt;END;</source>
<body class="oracle.dbtools.crest.model.design.storage.oracle.PackageBodyOracle" name="DD_PAYMENT_PKG" id="6D426B92-36E6-345E-69BC-B9F4D2B4CD73">
<sourceConnName>dd</sourceConnName>
<sourceObjSchema>DD</sourceObjSchema>
<sourceObjName>DD_PAYMENT_PKG</sourceObjName>
<createdBy>bcarter</createdBy>
<createdTime>2015-07-15 22:15:20 UTC</createdTime>
<ownerDesignName>dd_schema_data_model</ownerDesignName>
<owner>29F77958-DE9B-AAEB-4F89-771962185EA5</owner>
<source>CREATE OR REPLACE PACKAGE BODY DD.DD_PAYMENT_PKG&lt;br/&gt;IS&lt;br/&gt;  queue_name   CONSTANT VARCHAR2 (100) := &apos;DD_NON_EBR.DD_NOTIFYQ&apos;;&lt;br/&gt;&lt;br/&gt;  /*&lt;br/&gt;   * Simple New User Registration&lt;br/&gt;   */&lt;br/&gt;  FUNCTION process_registration (&lt;br/&gt;    dino_name_p        IN VARCHAR2,&lt;br/&gt;    password1_p        IN VARCHAR2,&lt;br/&gt;    password2_p        IN VARCHAR2,&lt;br/&gt;    dinosaur_id_p      IN INTEGER,&lt;br/&gt;    location_id_p      IN INTEGER,&lt;br/&gt;    about_yourself_p   IN VARCHAR2,&lt;br/&gt;    card_number_p      IN INTEGER,&lt;br/&gt;    amount_p           IN INTEGER)&lt;br/&gt;    RETURN INTEGER&lt;br/&gt;  AS&lt;br/&gt;    card_ok_l     INTEGER;&lt;br/&gt;    member_id_l   INTEGER;&lt;br/&gt;    BEGIN&lt;br/&gt;      IF    LENGTH (password1_p) != LENGTH (password2_p)&lt;br/&gt;            OR password1_p != password2_p&lt;br/&gt;      THEN&lt;br/&gt;        RETURN (0);&lt;br/&gt;      END IF;&lt;br/&gt;&lt;br/&gt;      -- Register the user and get their new member_id.&lt;br/&gt;      INSERT INTO dd_members (dinosaur_id,&lt;br/&gt;                              location_id,&lt;br/&gt;                              dino_name,&lt;br/&gt;                              about_yourself,&lt;br/&gt;                              subscription_status)&lt;br/&gt;      VALUES (dinosaur_id_p,&lt;br/&gt;              location_id_p,&lt;br/&gt;              dino_name_p,&lt;br/&gt;              about_yourself_p,&lt;br/&gt;              &apos;P&apos;) --  subscription status is marked &apos;P&apos; for pending.&lt;br/&gt;      RETURNING member_id&lt;br/&gt;      INTO member_id_l;&lt;br/&gt;&lt;br/&gt;      -- Process the credit card payment&lt;br/&gt;      dd_process_cc_payment (member_id_l,&lt;br/&gt;                             dino_name_p,&lt;br/&gt;                             card_number_p,&lt;br/&gt;                             amount_p);&lt;br/&gt;&lt;br/&gt;      -- Send the user a welcome message&lt;br/&gt;      dd_admin_pkg.send_message (&lt;br/&gt;          dd_admin_pkg.c_admin_id,&lt;br/&gt;          member_id_l,&lt;br/&gt;          &apos;Welcome to DinoDate&apos;,&lt;br/&gt;          &apos;When it comes to dinosaurs and love, DinoDate is the place to be!&apos;);&lt;br/&gt;&lt;br/&gt;      COMMIT;&lt;br/&gt;&lt;br/&gt;      RETURN (member_id_l);&lt;br/&gt;    END;&lt;br/&gt;&lt;br/&gt;  /*&lt;br/&gt;   * Enqueue Message Procedure&lt;br/&gt;   */&lt;br/&gt;  PROCEDURE queue_payment (p_message IN dd_user_payment_type)&lt;br/&gt;  IS&lt;br/&gt;    enq_opt    DBMS_AQ.ENQUEUE_OPTIONS_T;&lt;br/&gt;    msg_prop   DBMS_AQ.MESSAGE_PROPERTIES_T;&lt;br/&gt;    msg_id     RAW (16);&lt;br/&gt;    BEGIN&lt;br/&gt;      enq_opt.visibility := DBMS_AQ.on_commit;&lt;br/&gt;      enq_opt.delivery_mode := DBMS_AQ.persistent;&lt;br/&gt;      DBMS_AQ.enqueue (queue_name           =&gt; queue_name,&lt;br/&gt;                       enqueue_options      =&gt; enq_opt,&lt;br/&gt;                       message_properties   =&gt; msg_prop,&lt;br/&gt;                       payload              =&gt; p_message,&lt;br/&gt;                       msgid                =&gt; msg_id);&lt;br/&gt;      COMMIT;&lt;br/&gt;    END;&lt;br/&gt;&lt;br/&gt;  /*&lt;br/&gt;   * Process the new user registration. Credit Card info is queued for verification.&lt;br/&gt;   */&lt;br/&gt;  FUNCTION process_registration_aq (&lt;br/&gt;    dino_name_p        IN VARCHAR2,&lt;br/&gt;    password1_p        IN VARCHAR2,&lt;br/&gt;    password2_p        IN VARCHAR2,&lt;br/&gt;    dinosaur_id_p      IN INTEGER,&lt;br/&gt;    location_id_p      IN INTEGER,&lt;br/&gt;    about_yourself_p   IN VARCHAR2,&lt;br/&gt;    card_number_p      IN INTEGER,&lt;br/&gt;    amount_p           IN INTEGER)&lt;br/&gt;    RETURN INTEGER&lt;br/&gt;  AS&lt;br/&gt;    card_ok_l     INTEGER;&lt;br/&gt;    member_id_l   INTEGER;&lt;br/&gt;    BEGIN&lt;br/&gt;      IF LENGTH (password1_p) != LENGTH (password2_p)&lt;br/&gt;         OR password1_p != password2_p&lt;br/&gt;      THEN&lt;br/&gt;        RETURN (0);&lt;br/&gt;      END IF;&lt;br/&gt;&lt;br/&gt;      -- Register the user and get their new member_id.&lt;br/&gt;      -- Their subscription status is marked &apos;P&apos; for pending.&lt;br/&gt;      INSERT INTO dd_members (dinosaur_id,&lt;br/&gt;                              location_id,&lt;br/&gt;                              dino_name,&lt;br/&gt;                              about_yourself,&lt;br/&gt;                              subscription_status)&lt;br/&gt;      VALUES (dinosaur_id_p,&lt;br/&gt;              location_id_p,&lt;br/&gt;              dino_name_p,&lt;br/&gt;              about_yourself_p,&lt;br/&gt;              &apos;P&apos;)&lt;br/&gt;      RETURNING member_id&lt;br/&gt;      INTO member_id_l;&lt;br/&gt;&lt;br/&gt;      -- Comment out the direct call to the payment process&lt;br/&gt;      -- dd_process_cc_payment(member_id_l, dino_name_p, card_number_p, amount_p);&lt;br/&gt;&lt;br/&gt;      -- Instead, send the payment details off to Advanced Queueing (AQ) for processing&lt;br/&gt;      dd_payment_pkg.queue_payment (&lt;br/&gt;          dd_user_payment_type (member_id_l,&lt;br/&gt;                                dino_name_p,&lt;br/&gt;                                card_number_p,&lt;br/&gt;                                amount_p));&lt;br/&gt;&lt;br/&gt;      -- Send them a welcome message&lt;br/&gt;      dd_admin_pkg.send_message (&lt;br/&gt;          dd_admin_pkg.c_admin_id,&lt;br/&gt;          member_id_l,&lt;br/&gt;          &apos;Welcome to DinoDate&apos;,&lt;br/&gt;          &apos;When it comes to dinosaurs and love, DinoDate is the place to be!&apos;);&lt;br/&gt;&lt;br/&gt;      COMMIT;&lt;br/&gt;&lt;br/&gt;      RETURN (member_id_l);&lt;br/&gt;    END;&lt;br/&gt;&lt;br/&gt;  /*&lt;br/&gt;   * An automatic new user registration dequeue procedure called via PL/SQL notification&lt;br/&gt;   */&lt;br/&gt;  PROCEDURE auto_dequeue (context     RAW,&lt;br/&gt;                          reginfo     SYS.AQ$_REG_INFO,&lt;br/&gt;                          descr       SYS.AQ$_DESCRIPTOR,&lt;br/&gt;                          payload     RAW,&lt;br/&gt;                          payloadl    NUMBER)&lt;br/&gt;  IS&lt;br/&gt;    l_message              dd_user_payment_type;&lt;br/&gt;    l_dequeue_options      DBMS_AQ.DEQUEUE_OPTIONS_T;&lt;br/&gt;    l_message_properties   DBMS_AQ.MESSAGE_PROPERTIES_T;&lt;br/&gt;    l_message_id           RAW (16);&lt;br/&gt;    l_processing_error     VARCHAR2 (4000);&lt;br/&gt;    l_payment_ok           INTEGER;&lt;br/&gt;    BEGIN&lt;br/&gt;      l_dequeue_options.msgid         := descr.msg_id;&lt;br/&gt;      l_dequeue_options.consumer_name := descr.consumer_name;&lt;br/&gt;      l_dequeue_options.visibility    := DBMS_AQ.on_commit;&lt;br/&gt;&lt;br/&gt;      -- Dequeue the message based on message id provided by AQ Notification&lt;br/&gt;      DBMS_AQ.dequeue (&lt;br/&gt;          queue_name           =&gt; queue_name,&lt;br/&gt;          dequeue_options      =&gt; l_dequeue_options,&lt;br/&gt;          message_properties   =&gt; l_message_properties,&lt;br/&gt;          payload              =&gt; l_message,&lt;br/&gt;          msgid                =&gt; l_message_id);&lt;br/&gt;&lt;br/&gt;      -- Post dequeue processing logic is here.&lt;br/&gt;      -- For the DinoDate app, dd_process_cc_payment handles payment processing&lt;br/&gt;      dd_process_cc_payment (l_message.member_id,&lt;br/&gt;                             l_message.dino_name,&lt;br/&gt;                             l_message.card_number,&lt;br/&gt;                             l_message.amount);&lt;br/&gt;&lt;br/&gt;      -- Note: AQ will (by default) recall this procedure five times if it raises an exception&lt;br/&gt;      -- After that the message will be moved to exception queue.&lt;br/&gt;      -- If COMMIT occurs in this callback procedure, the message will be removed from the queue.&lt;br/&gt;      -- So this procedure may be recalled but there would&apos;t be anything to de-queue.&lt;br/&gt;      -- The retry count and retry delay are configurable&lt;br/&gt;&lt;br/&gt;      EXCEPTION&lt;br/&gt;      WHEN OTHERS&lt;br/&gt;      THEN&lt;br/&gt;      ROLLBACK;&lt;br/&gt;      -- In case of errors user can log the error message into&lt;br/&gt;      -- some table e.g dd_dequeue_errors in this example&lt;br/&gt;      l_processing_error := SQLCODE || &apos; - &apos; || SQLERRM;&lt;br/&gt;&lt;br/&gt;      INSERT INTO dd_dequeue_errors (error_message)&lt;br/&gt;      VALUES (l_processing_error);&lt;br/&gt;&lt;br/&gt;      COMMIT;&lt;br/&gt;      -- Please note that user App needs to raise an error in it&lt;br/&gt;      -- expects AQ Notification to retry again&lt;br/&gt;      RAISE;&lt;br/&gt;    END auto_dequeue;&lt;br/&gt;&lt;br/&gt;END dd_payment_pkg;</source>
</body>
</PackageOracle>